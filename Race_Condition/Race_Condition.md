# **Race conditions**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">They occur when websites process requests concurrently without adequate safeguards. This can lead to multiple distinct threads interacting with the same data at the same time, resulting in a "collision" that causes unintended behavior in the application</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">The period of time during which a collision is possible is known as the "race window". This could be the fraction of a second between two interactions with the database</span>

## **Limit overrun race conditions**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">The most well-known type of race condition enables you to exceed some kind of limit imposed by the business logic of the application the application transitions through a temporary sub-state; that is, a state that it enters and then exits again before request processing is complete.This introduces a small race window during which you can repeatedly claim the discount as many times as you like.</span>

- <span style="font-size: 17px">Bypassing an anti-brute-force rate limit</span>


- <span style="font-size: 17px">Redeeming a gift card multiple times</span>
- <span style="font-size: 17px">Rating a product multiple times</span>
- <span style="font-size: 17px">Withdrawing or transferring cash in excess of your account balance</span>
- <span style="font-size: 17px">Reusing a single CAPTCHA solution</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Limit overruns are a subtype of so-called "time-of-check to time-of-use" (TOCTOU) flaws</span>

### **<span style="font-size: 19px">Detecting and exploiting limit overrun race conditions with Burp Repeater</span>**

- <span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Identify a single-use or rate-limited endpoint that has some kind of security impact or other useful purpose</span>
- <span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Issue multiple requests to this endpoint in quick succession to see if you can overrun this limit</span>

 <span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">The primary challenge is timing the requests so that at least two race windows line up, causing a collision. This window is often just milliseconds and can be even shorter.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">The single-packet attack enables you to completely neutralize interference from network jitter by using a single TCP packet to complete 20-30 requests simultaneously.</span>

### **<span style="font-size: 19px">Detecting and exploiting limit overrun race conditions with Turbo Intruder</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To use the single-packet attack in Turbo Intruder:</span>

1. <span style="font-size: 17px">Ensure that the target supports HTTP/2. The single-packet attack is incompatible with HTTP/1.</span>
2. <span style="font-size: 17px">Set the </span>`engine=Engine.BURP2`<span style="font-size: 17px"> and </span>`concurrentConnections=1`<span style="font-size: 17px"> configuration options for the request engine.</span>
3. <span style="font-size: 17px">When queueing your requests, group them by assigning them to a named gate using the </span>`gate`<span style="font-size: 17px"> argument for the </span>`engine.queue()`<span style="font-size: 17px"> method.</span>
4. <span style="font-size: 17px">To send all of the requests in a given group, open the respective gate with the </span>`engine.openGate()`<span style="font-size: 17px"> method.</span>

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                            concurrentConnections=1,
                            engine=Engine.BURP2
                            )
    
    # queue 20 requests in gate '1'
    for i in range(20):
        engine.queue(target.req, gate='1')
    
    # send all requests in gate '1' in parallel
    engine.openGate('1')
        
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">the </span>`race-single-packet-attack.py`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> template provided in Turbo Intruder's default examples directory.</span>

## **Hidden multi-step sequences**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">In practice, a single request may initiate an entire multi-step sequence behind the scenes, transitioning the application through multiple hidden states that it enters and then exits again before request processing is complete</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If you can identify one or more HTTP requests that cause an interaction with the same data, you can potentially abuse these sub-states to expose time-sensitive variations of the kinds of logic flaws that are common in multi-step workflows.</span>

## **Methodology for Hidden multi-step Sequence:**

### **<span style="font-size: 21px">Predict potential collisions</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">After mapping out the target site as normal, you can reduce the number of endpoints that you need to test by asking yourself the following questions:</span>

- <span style="font-size: 19px">Is this endpoint security critical?</span>
- <span style="font-size: 19px">Is there any collision potential?</span>

### **<span style="font-size: 21px">Probe for clues</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To recognize clues, you first need to benchmark how the endpoint behaves under normal conditions. You can do this in Burp Repeater by grouping all of your requests and using the </span>**<span style="font-size: 17px">Send group in sequence (separate connections)</span>**<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> option.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Next, send the same group of requests at once using the single-packet attack (or last-byte sync if HTTP/2 isn't supported) to minimize network jitter</span>

### **<span style="font-size: 19px">Prove the concept</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Try to understand what's happening, remove superfluous requests, and make sure you can still replicate the effects.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Advanced race conditions can cause unusual and unique primitives, so the path to maximum impact isn't always immediately obvious. It may help to think of each race condition as a structural weakness rather than an isolated vulnerability.</span>

## **Multi-endpoint race conditions**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Perhaps the most intuitive form of these race conditions are those that involve sending requests to multiple endpoints at the same time.</span>

**<span style="font-size: 19px">LAB</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">try to place item after checkout window in parallel to cause the system to believe that the item is also needed to be checkout but due to the speed in parallel connection is goes on without a check the item is bought at a negative price.</span>

### **<span style="font-size: 17px">Aligning multi-endpoint race windows</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">This common problem is primarily caused by the following two factors:</span>

- <span style="font-size: 19px">Delays introduced by network architecture</span>
- <span style="font-size: 19px">Delays introduced by endpoint-specific processing</span>

#### **<span style="font-size: 17px">Connection warming</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Back-end connection delays don't usually interfere with race condition attacks because they typically delay parallel requests equally, so the requests stay in sync.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">One way to do this is by "warming" the connection with one or more inconsequential requests to see if this smoothes out the remaining processing times.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If the first request still has a longer processing time, but the rest of the requests are now processed within a short window, you can ignore the apparent delay and continue testing as normal.</span>

#### **<span style="font-size: 17px">Abusing rate or resource limits</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Web servers often delay the processing of requests if too many are sent too quickly. By sending a large number of dummy requests to intentionally trigger the rate or resource limit, you may be able to cause a suitable server-side delay. This makes the single-packet attack viable even when delayed execution is required.</span>

## **Single-endpoint race conditions**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Sending parallel requests with different values to a single endpoint can sometimes trigger powerful race conditions.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Consider a password reset mechanism that stores the user ID and reset token in the user's session.sending two parallel password reset requests from the same session, but with two different usernames, could potentially cause the following collision</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Email address confirmations, or any email-based operations, are generally a good target for single-endpoint race conditions.</span>

## **Session-based locking mechanisms**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Some frameworks attempt to prevent accidental data corruption by using some form of request locking. For example, PHP's native session handler module only processes one request per session at a time</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">It's extremely important to spot this kind of behavior as it can otherwise mask trivially exploitable vulnerabilities. If you notice that all of your requests are being processed sequentially, try sending each of them using a different session token.</span>

## **Partial construction race conditions**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Many applications create objects in multiple steps, which may introduce a temporary middle state in which the object is exploitable.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">the way for exploits whereby you inject an input value that returns something matching the uninitialized database value, such as an empty string, or </span>`null`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> in JSON, and this is compared as part of a security control.</span>

## **Time-sensitive attacks**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Sometimes you may not find race conditions, but the techniques for delivering requests with precise timing can still reveal the presence of other vulnerabilities.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Consider a password reset token that is only randomized using a timestamp. In this case, it might be possible to trigger two password resets for two different users, which both use the same token. All you need to do is time the requests so that they generate the same timestamp.</span>

## **How to prevent race condition vulnerabilities**

- <span style="font-size: 17px">Avoid mixing data from different storage places.</span>
- <span style="font-size: 17px">Ensure sensitive endpoints make state changes atomic by using the datastore's concurrency features. For example, use a single database transaction to check the payment matches the cart value and confirm the order.</span>
- <span style="font-size: 17px">As a defense-in-depth measure, take advantage of datastore integrity and consistency features like column uniqueness constraints.</span>
- <span style="font-size: 17px">Don't attempt to use one data storage layer to secure another. For example, sessions aren't suitable for preventing limit overrun attacks on databases.</span>
- <span style="font-size: 17px">Ensure your session handling framework keeps sessions internally consistent. Updating session variables individually instead of in a batch might be a tempting optimization, but it's extremely dangerous. This goes for ORMs too; by hiding away concepts like transactions, they're taking on full responsibility for them.</span>
- <span style="font-size: 17px">In some architectures, it may be appropriate to avoid server-side state entirely. Instead, you could use encryption to push the state client-side, for example, using JWTs. Note that this has its own risks, as we've covered extensively in our topic on </span>[<span style="font-size: 17px">JWT attacks</span>](https://portswigger.net/web-security/jwt)<span style="font-size: 17px">.</span>